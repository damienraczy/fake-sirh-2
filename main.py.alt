#!/usr/bin/env python3
# =============================================================================
# main.py - G√©n√©rateur de donn√©es SIRH complet
# =============================================================================

import argparse
import sys
import time
from pathlib import Path
from typing import List

# Ajouter le r√©pertoire courant au path
sys.path.insert(0, str(Path(__file__).parent))

from core.config import load_config, get_config

# =============================================================================
# Configuration des √©tapes
# =============================================================================

STEPS = {
    0: {
        'name': 'Initialisation',
        'module': 'data_generation.steps.e00_initialisation',
        'description': 'Initialisation de la base de donn√©es',
        'required': True
    },
    1: {
        'name': 'Structure organisationnelle',
        'module': 'data_generation.steps.e01_structure_organisationnelle',
        'description': 'Cr√©ation des unit√©s organisationnelles',
        'dependencies': [0]
    },
    2: {
        'name': 'Population et hi√©rarchie',
        'module': 'data_generation.steps.e02_population_hierarchie',
        'description': 'G√©n√©ration des employ√©s et de la hi√©rarchie',
        'dependencies': [0, 1]
    },
    3: {
        'name': 'Comp√©tences',
        'module': 'data_generation.steps.e03_competences_referentiels',
        'description': 'G√©n√©ration des comp√©tences et r√©f√©rentiels',
        'dependencies': [0, 1, 2]
    },
    4: {
        'name': 'Objectifs et performance',
        'module': 'data_generation.steps.e04_objectifs_performance',
        'description': 'G√©n√©ration des objectifs et √©valuations',
        'dependencies': [0, 1, 2]
    },
    5: {
        'name': 'Formations',
        'module': 'data_generation.steps.e05_formations_developpement',
        'description': 'G√©n√©ration des formations et d√©veloppement',
        'dependencies': [0, 1, 2, 3]
    },
    6: {
        'name': 'Feedback et documents',
        'module': 'data_generation.steps.e06_feedback_documents',
        'description': 'G√©n√©ration des feedback et documents',
        'dependencies': [0, 1, 2]
    },
    7: {
        'name': 'Indexation RAG',
        'module': 'data_generation.steps.e07_rag_indexation',
        'description': 'Indexation des donn√©es pour le RAG',
        'dependencies': [0, 1, 2, 3, 4, 5, 6]
    },
    8: {
        'name': 'Synchronisation Neo4j',
        'module': 'data_generation.steps.e08_neo4j_sync',
        'description': 'Synchronisation vers Neo4j',
        'dependencies': [0, 1, 2, 3, 4, 5, 6]
    }
}

# =============================================================================
# Fonctions utilitaires
# =============================================================================

def print_banner():
    """Affiche la banni√®re de d√©marrage"""
    print("=" * 70)
    print(" " * 15 + "üè¢ G√âN√âRATEUR DE DONN√âES SIRH")
    print("=" * 70)
    print()

def print_step_header(step_num: int, step_info: dict):
    """Affiche l'en-t√™te d'une √©tape"""
    print("\n" + "‚îÄ" * 70)
    print(f"√âTAPE {step_num}: {step_info['name'].upper()}")
    print(f"Description: {step_info['description']}")
    print("‚îÄ" * 70)

def print_summary(executed_steps: List[int], total_time: float, errors: dict):
    """Affiche le r√©sum√© de l'ex√©cution"""
    print("\n" + "=" * 70)
    print(" " * 25 + "üìä R√âSUM√â")
    print("=" * 70)
    print(f"\n‚úÖ √âtapes ex√©cut√©es: {len(executed_steps)}/{len(STEPS)}")
    print(f"‚è±Ô∏è  Temps total: {total_time:.2f}s ({total_time/60:.2f}min)")
    
    if errors:
        print(f"\n‚ùå Erreurs: {len(errors)}")
        for step_num, error in errors.items():
            print(f"   ‚Ä¢ √âtape {step_num}: {error}")
    else:
        print("\n‚úÖ Toutes les √©tapes ont √©t√© ex√©cut√©es avec succ√®s!")
    
    print("\n" + "=" * 70)

def validate_dependencies(steps_to_run: List[int]) -> List[int]:
    """Valide et compl√®te les d√©pendances des √©tapes"""
    required_steps = set(steps_to_run)
    
    # Ajouter les d√©pendances
    for step_num in steps_to_run:
        if step_num in STEPS and 'dependencies' in STEPS[step_num]:
            required_steps.update(STEPS[step_num]['dependencies'])
    
    # Toujours inclure l'√©tape 0 (initialisation)
    required_steps.add(0)
    
    return sorted(list(required_steps))

def import_step_module(module_name: str):
    """Importe dynamiquement un module d'√©tape"""
    try:
        module = __import__(module_name, fromlist=['run'])
        return module
    except ImportError as e:
        raise ImportError(f"Impossible d'importer le module {module_name}: {e}")

def execute_step(step_num: int, step_info: dict) -> tuple:
    """Ex√©cute une √©tape et retourne (succ√®s, temps, erreur)"""
    try:
        print_step_header(step_num, step_info)
        
        # Import dynamique du module
        module = import_step_module(step_info['module'])
        
        # Ex√©cuter l'√©tape avec chronom√©trage
        start_time = time.time()
        module.run()
        execution_time = time.time() - start_time
        
        print(f"\n‚úÖ √âtape {step_num} termin√©e en {execution_time:.2f}s")
        return True, execution_time, None
        
    except Exception as e:
        print(f"\n‚ùå Erreur lors de l'√©tape {step_num}: {e}")
        import traceback
        traceback.print_exc()
        return False, 0, str(e)

# =============================================================================
# Fonction principale
# =============================================================================

def main():
    """Point d'entr√©e principal"""
    # Parser les arguments
    parser = argparse.ArgumentParser(
        description='G√©n√©rateur de donn√©es SIRH avec 8 √©tapes',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:
  %(prog)s --all                    # Ex√©cuter toutes les √©tapes
  %(prog)s 0 1 2                    # Ex√©cuter les √©tapes 0, 1 et 2
  %(prog)s --from 3 --to 5          # Ex√©cuter les √©tapes 3 √† 5
  %(prog)s --yaml custom_config.yaml # Utiliser une config personnalis√©e
  %(prog)s --all --raz              # Tout r√©g√©n√©rer (avec RAZ de la BD)

Liste des √©tapes:
  0: Initialisation de la base de donn√©es
  1: Structure organisationnelle
  2: Population et hi√©rarchie
  3: Comp√©tences et r√©f√©rentiels
  4: Objectifs et performance
  5: Formations et d√©veloppement
  6: Feedback et documents
  7: Indexation RAG
  8: Synchronisation Neo4j
        """
    )
    
    # Arguments de s√©lection des √©tapes
    parser.add_argument('steps', nargs='*', type=int, 
                       help='Num√©ros des √©tapes √† ex√©cuter (0-8)')
    parser.add_argument('--all', action='store_true',
                       help='Ex√©cuter toutes les √©tapes')
    parser.add_argument('--from', dest='from_step', type=int,
                       help='√âtape de d√©part (inclusive)')
    parser.add_argument('--to', dest='to_step', type=int,
                       help='√âtape de fin (inclusive)')
    
    # Arguments de configuration
    parser.add_argument('--yaml', dest='config_file', default='config.yaml',
                       help='Fichier de configuration YAML (d√©faut: config.yaml)')
    parser.add_argument('--raz', action='store_true',
                       help='Forcer la r√©initialisation compl√®te (RAZ de la BD)')
    
    # Arguments d'affichage
    parser.add_argument('--list', action='store_true',
                       help='Lister les √©tapes disponibles et quitter')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Mode verbeux')
    
    args = parser.parse_args()
    
    # Lister les √©tapes et quitter
    if args.list:
        print("√âtapes disponibles:")
        for num, info in STEPS.items():
            deps = f" (d√©pend de: {info.get('dependencies', [])})" if info.get('dependencies') else ""
            print(f"  {num}: {info['name']} - {info['description']}{deps}")
        return 0
    
    # Charger la configuration
    try:
        load_config(args.config_file)
        config = get_config()
        print(f"‚úÖ Configuration charg√©e depuis: {args.config_file}")
        print(f"   Entreprise: {config['entreprise']['nom']}")
        print(f"   Secteur: {config['entreprise']['secteur']}")
        print(f"   Taille: {config['entreprise']['taille']} employ√©s")
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement de la configuration: {e}")
        return 1
    
    # D√©terminer les √©tapes √† ex√©cuter
    steps_to_run = []
    
    if args.all:
        steps_to_run = list(STEPS.keys())
    elif args.from_step is not None and args.to_step is not None:
        steps_to_run = list(range(args.from_step, args.to_step + 1))
    elif args.from_step is not None:
        steps_to_run = list(range(args.from_step, max(STEPS.keys()) + 1))
    elif args.to_step is not None:
        steps_to_run = list(range(0, args.to_step + 1))
    elif args.steps:
        steps_to_run = args.steps
    else:
        print("‚ùå Aucune √©tape sp√©cifi√©e. Utilisez --all, --from/--to, ou sp√©cifiez des num√©ros d'√©tapes.")
        print("   Utilisez --help pour voir les options disponibles.")
        return 1
    
    # Valider et compl√©ter les d√©pendances
    steps_to_run = validate_dependencies(steps_to_run)
    
    # V√©rifier que les √©tapes existent
    invalid_steps = [s for s in steps_to_run if s not in STEPS]
    if invalid_steps:
        print(f"‚ùå √âtapes invalides: {invalid_steps}")
        print(f"   √âtapes valides: {list(STEPS.keys())}")
        return 1
    
    # Afficher le plan d'ex√©cution
    print_banner()
    print("üìã Plan d'ex√©cution:")
    for step_num in steps_to_run:
        print(f"   ‚Ä¢ √âtape {step_num}: {STEPS[step_num]['name']}")
    print()
    
    if args.raz:
        print("‚ö†Ô∏è  MODE RAZ: La base de donn√©es sera r√©initialis√©e!")
        response = input("Continuer? (oui/non): ")
        if response.lower() not in ['oui', 'o', 'yes', 'y']:
            print("Op√©ration annul√©e.")
            return 0
        # L'√©tape 0 g√®re la RAZ automatiquement
    
    # Ex√©cuter les √©tapes
    print("\nüöÄ D√©marrage de l'ex√©cution...")
    
    total_start_time = time.time()
    executed_steps = []
    errors = {}
    
    for step_num in steps_to_run:
        success, exec_time, error = execute_step(step_num, STEPS[step_num])
        
        if success:
            executed_steps.append(step_num)
        else:
            errors[step_num] = error
            
            # Demander si on continue apr√®s une erreur
            print("\n‚ö†Ô∏è  Une erreur s'est produite.")
            response = input("Continuer avec les √©tapes suivantes? (oui/non): ")
            if response.lower() not in ['oui', 'o', 'yes', 'y']:
                print("Ex√©cution interrompue.")
                break
    
    total_time = time.time() - total_start_time
    
    # Afficher le r√©sum√©
    print_summary(executed_steps, total_time, errors)
    
    # Informations post-ex√©cution
    if 7 in executed_steps:
        print("\nüí° Syst√®me RAG:")
        print("   ‚Ä¢ D√©marrer l'API: python rag_system/start_rag_api.py")
        print("   ‚Ä¢ URL: http://localhost:8000")
    
    if 8 in executed_steps:
        print("\nüí° Neo4j:")
        print("   ‚Ä¢ Browser: http://localhost:7474")
        print("   ‚Ä¢ Explorer la hi√©rarchie: MATCH (e:Employee)-[:MANAGES]->(s) RETURN e, s LIMIT 25")
    
    # Code de sortie
    return 0 if not errors else 1

# =============================================================================
# Point d'entr√©e
# =============================================================================

if __name__ == "__main__":
    sys.exit(main())